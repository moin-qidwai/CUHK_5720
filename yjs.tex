\documentclass[12pt]{report}
\usepackage[T1]{fontenc}

\title{YJS Deep Dive and Analysis}
\date{2021-09-26}
\author{Moin Ahmed Qidwai}

\begin{document}
  \maketitle
  \newpage

  \section{Introduction}
  Near-real time (NRT) collaboration is the goal of many software applications, from collaborative text-editors like Google Docs to modelling applications like Autodesk Maya.
  In reality most applications could benefit from allowing users to collaborate effectively regardless of the problem domain that the application targets.
  As such the reason that so few of the mainstream software supports this functionality is generally the result of complexity accompanied with solutions to this problem.
  While there are a few different methodologies for supporting NRT collaboration, in this paper we shall investigate YJS, a popular library implementing the YATA approach.

  \section{Collaboration Objectives}
  In order for a solution to be considered for NRT collaboration, it must be able to satisfy certain conditions or objectives.
  
  \subsection{Eventual Convergence}
  Eventual convergence dictates that if two collaborators receive the same set of operations in any order,
  the end result of those operations must be the same for both the collaborators.\\
  That is, If we have a algorithm \(A\) for merging operations into a list and two sets of operations \(S_{1}\) and \(S_{2}\) that observe the below relation.
  \begin{equation}
    \forall o : o \in S_{1} \leftrightarrow o \in S_{2}
  \end{equation}
  
  Then the following must hold true, where \(\mapsto\) represents an input symbol.
  \begin{equation}
     S_{1} \mapsto A \equiv S_{2} \mapsto A
  \end{equation}

  \subsection{Intention Preservation}
  The idea behind preservation of intention is simple. Any solution that aims to provide for NRT collaboration must ensure the result is in accordance with the intention of all collaborators.

  \subsection{Interleaving}
  Interleaving occurs if two or more collaborators insert multiple characters at the same index, upon integrating their insertions the result may have their inputs mixed.\\
  Example: Collaborators \(C_{1}\) and \(C_{2}\) add "vious" and "cious" to "pre". If interleaving occurs the result may be "prevcioiouuss".
  A program that allows for NRT collaboration must ensure interleaving cannot occur.

  \section{YATA}
  The YATA (Yet Another Transformation approach) is the core specification underlying YJS.
  This specification consists of two main components, a doubly linked list and a set of rules that all operations must observe.
  
  \subsection{Data Representation}
  The doubly linked list representation used by YATA is in contrast to other algorithms. Another popular algorithm is the RGA, which utilizes a uni-directional linked list.
  The doubly linked list allows YATA to avoid interleaving at the start of the document or in prepend operations.
  As such it can cater for a wider range of operations and use cases than RGA by default. Though due to storing a pointer to the successor the data representation in YATA requires more memory.
  \begin{equation} \label{block}
    Block_{i} = (id_{i}, origin_{left}, origin_{right}, deleted_{i}, value_{i})
  \end{equation}
  Equation \ref{block} represents a single element in the linked list of YATA. The origins represent the pointers to predecessor and successor elements.
  \begin{equation} \label{identifier}
    id_{i} = (replica_{i}, counter_{i})
  \end{equation}
  Equation \ref{identifier} represents the identifier for a single block in the linked list. It consists of the Replica ID (or user id) and the operation counter.\\\\
  The above representation ensures each block has a unique identifier and a total order. 
  
  \subsection{Operations}
  The YATA specification only outlines two types of operations: insertion and deletion.
  A combination of these operations can also lead to many others, for example the update operation.

  \subsubsection{Insertion}
  \begin{equation} \label{insert_operation}
    Operation_{k} = (id_{k}, origin_{k}, left_{k}, right_{k}, deleted_{k}, value_{k})
  \end{equation}
  Equation \ref{insert_operation} represents the insertion operation with counter (k).
  The \underline{\textbf{origin}} represents the predecessor for the block at the time of creation.
  The \underline{\textbf{left}} and \underline{\textbf{right}} represent the predecessor and successor respectively after the operation has been merged into the linked list.
  The \underline{\textbf{deleted}} flag indicates if the block representing the operation has been marked for deletion.
  The \underline{\textbf{value}} is the actual content that is to be inserted.
  
  \subsubsection{Deletion}
  The deletion operation is simply represented by setting the deleted flag of the insertion operation to \textbf{true}.
  
  \begin{equation} \label{deletion_operation}
    Operation_{k} = (id_{k}, origin_{k}, left_{k}, right_{k}, true, value_{k})
  \end{equation}

  \subsubsection{Operation Ordering}
  Every operation block has a total order in the list defined by the natural predecessor relation \textbf{<}.
  \begin{equation}
    O_{1} < O_{2} \leftrightarrow O_{1} is\ a\ predecessor\ of\ O_{2}
  \end{equation}
  \begin{equation}
    O_{1} \leq O_{2} \leftrightarrow O_{1} < O_{2} \lor O_{1} \equiv O_{2}
  \end{equation}
  Given the above predecessor relation and insert operation we can represent an insertion between two operations \(O_{i}\ and\ O_{j}\) as shown below.
  \begin{equation} \label{insert_operation_example}
    Operation_{new} = (id_{new}, O_{i}, O_{i}, O_{j}, false, value_{new})
  \end{equation}
  In equation \ref{insert_operation_example} the following relation must hold \(O_{i}\ <\ Operation_{new}\ <\ O_{j}\).\\\\
  As one may notice the origin and the left operation are the same in the above equation as this represents the operation at the time of it's creations.
  The origin for the operation is set at the time of the operation creation and does not change thereafter.
  The left pointer may change during the merge process of operations created by different replicas, if there are conflicts.

  \subsection{Rules of Conflict Resolution}
  As mentioned earlier in this paper YATA consists of certain rules that must be observed by operations specially in cases of conflicts.
  These rules are the cornerstone of the YATA approach as they ensure \textbf{eventual convergence} and \textbf{intention preservation}.

  \subsubsection{Conflicting insertions}
  Insertion operations (\(O_{a}\), \(O_{b}\), ...) are in conflict if all of them are to be inserted between \(O_{i}\) and \(O_{j}\).
  In the above example, if \(Operation_{new}\) is to be integrated in the list of operations \(L = [O_{i}, c_{a}, c_{b}, c_{c}... O_{j}]\),
  then \(Operation_{new}\) is in conflict with [\(c_{a}, c_{b}, c_{c}, ...\)]. The rules resolve these conflicts by calculating the index \(k\) for the new insertion.
  If the rules are observed by all collaborators then each of them calculates the same index. Each rule can be illustrated as a predecessor relation \(<_{r}\).
  As such if we observe these rules for \(Operation_{new}\) then we integrate it between \(c_{i}\) and \(c_{j}\) where \(\forall r: c_{i}\ <_{r}\ Operation_{new}\ <_{r}\ c_{j}\).

  \subsubsection{Rule One}
  The first rule dictates that for two conflicting insertions \(I_{a}\) and \(I_{b}\) that have different origins \(O_{a}\) and \(O_{b}\) respectively,
  the connection between \(I_{a}\) and \(O_{a}\) must not be intersected by the connection between \(I_{b}\) and \(O_{b}\), or vice versa.
  The only instances where the above holds true is illustrated by the below ordered sets (and their opposites, which one can get by swapping the indexes \(a\) and \(b\)).
  \begin{equation} \label{rule_one_order_one}
    [O_{a}, O_{b}, I_{b}, I_{a}]
  \end{equation}
  \begin{equation} \label{rule_one_order_two}
    [O_{a}, I_{a}, O_{b}, I_{b}]
  \end{equation}

  Set \ref{rule_one_order_one} represents the case where a operation and it's origin are inserted in between of the other operation and it's origin.
  Set \ref{rule_one_order_two} represents the case where a operation and it's origin are inserted after the other operation and it's origin.

  Rule one then can be succinctly illustrated by the below equation.
  \begin{equation} \label{rule_one_equation}
    O_{a} <_{r1} O_{b} \leftrightarrow O_{a} < Origin_{b} \lor Origin_{b} \leq Origin_{a}
  \end{equation}

  \subsubsection{Rule Two}
  Rule two is the standard rule of transitivity and can be illustrated by the below equation.
  \begin{equation} \label{rule_two_equation}
    O_{a} <_{r2} O_{b} \leftrightarrow \forall O: O_{b} <_{r2} O \rightarrow O_{a} \leq O
  \end{equation}

  \subsubsection{Rule Three}
  Rule three dictates that if two conflicting insertions have the same origin, then the insertion with the smaller creator ID is to the left.
  It can be represented by the below equation.
  \begin{equation} \label{rule_three_equation}
    O_{a} <_{r3} O_{b} \leftrightarrow Origin_{a} \equiv Origin_{b} \rightarrow Creator_{a} < Creator_{b}
  \end{equation}

  \subsubsection{Total Order Function}
  If we combine all the three rules by conjunction and utilize them for insertions we get a total order on the insertion operations.
  This ensures both \textbf{eventual convergence} and \textbf{intention preservation}.

  \section{YJS}
  YJS is an implementation of the YATA specification, though it does couple it with delta-state based operations.
  In other words it only passes the specific operations that changed per integration, as opposed to the full document as per the YATA specification.
  This ensures the size of the messages remains small and hence the burden on the network resources is minimized.\\
  The main disadvantage of YJS along with YATA is that when each character is represented as an operation as opposed to a single character, the overall document takes greater space.
  Though this is compensated with generally lower time complexity and the small size of the propagated messages.

  \section{Conclusion}
  The YATA approach resolves many of the short-comings of other NRT collaboration approaches.
  It can be utilized to represent a multitude of data types and hence can cater for a wide range of applications.
  YJS is the most popular implementation of YATA, though it adds many optimizations beyond the core.
  It also has significant advantages over operational transformation based techniques, which we will look at next.
\end{document}